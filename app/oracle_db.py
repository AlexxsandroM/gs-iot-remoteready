import oracledb
from contextlib import contextmanager
from datetime import datetime
import os
from dotenv import load_dotenv

load_dotenv()

# Configurações do Oracle DB
ORACLE_USER = os.getenv("ORACLE_USER", "seu_usuario")
ORACLE_PASSWORD = os.getenv("ORACLE_PASSWORD", "sua_senha")
ORACLE_DSN = os.getenv("ORACLE_DSN", "localhost:1521/XEPDB1")

@contextmanager
def get_oracle_conn():
    """Context manager para conexão Oracle"""
    conn = oracledb.connect(
        user=ORACLE_USER,
        password=ORACLE_PASSWORD,
        dsn=ORACLE_DSN
    )
    try:
        yield conn
    finally:
        conn.close()

def init_oracle_db():
    """Verifica a conexão com o Oracle e cria a tabela TB_GS_CHAT_HISTORY se não existir"""
    try:
        with get_oracle_conn() as conn:
            cur = conn.cursor()
            
            # Verifica se a tabela TB_GS_CHAT_HISTORY existe
            cur.execute("""
                SELECT COUNT(*) 
                FROM user_tables 
                WHERE table_name = 'TB_GS_CHAT_HISTORY'
            """)
            count = cur.fetchone()[0]
            
            if count == 0:
                print("⚠️  Tabela TB_GS_CHAT_HISTORY não encontrada. Criando...")
                
                # Cria a tabela TB_GS_CHAT_HISTORY
                cur.execute("""
                    CREATE TABLE TB_GS_CHAT_HISTORY (
                        ID_CHAT       NUMBER GENERATED BY DEFAULT AS IDENTITY
                                      CONSTRAINT PK_TB_GS_CHAT_HISTORY PRIMARY KEY,
                        ID_USUARIO    NUMBER(6)    NOT NULL,
                        DS_PROMPT     CLOB         NOT NULL,
                        DS_RESPONSE   CLOB,
                        DT_CRIACAO    DATE         DEFAULT SYSDATE NOT NULL
                    )
                """)
                
                # Cria índices para performance
                cur.execute("""
                    CREATE INDEX IDX_GS_CHAT_USUARIO ON TB_GS_CHAT_HISTORY(ID_USUARIO)
                """)
                
                cur.execute("""
                    CREATE INDEX IDX_GS_CHAT_DATA ON TB_GS_CHAT_HISTORY(DT_CRIACAO)
                """)
                
                conn.commit()
                print("✓ Tabela TB_GS_CHAT_HISTORY criada com sucesso")
            else:
                print("✓ Tabela TB_GS_CHAT_HISTORY já existe")
            
            print("✓ Conexão com Oracle estabelecida")
            
    except oracledb.Error as e:
        raise Exception(f"Erro ao conectar com Oracle: {e}")

def save_message_oracle(user_id: int, user_message: str, bot_answer: str):
    """Salva uma mensagem do chat na tabela TB_GS_CHAT_HISTORY usando a procedure PRC_INSERIR_CHAT_HISTORY"""
    with get_oracle_conn() as conn:
        cur = conn.cursor()
        
        # Variável de saída para receber o ID gerado
        id_chat = cur.var(int)
        
        # Chama a procedure do package
        cur.callproc('PKG_REMOTEREADY.PRC_INSERIR_CHAT_HISTORY', [
            user_id,           # P_ID_USUARIO
            user_message,      # P_PROMPT
            bot_answer,        # P_RESPONSE
            id_chat            # P_ID_OUT
        ])
        
        conn.commit()
        return id_chat.getvalue()[0]

def get_user_history(user_id: int, limit: int = 10):
    """Recupera o histórico de conversas de um usuário da tabela TB_GS_CHAT_HISTORY"""
    with get_oracle_conn() as conn:
        cur = conn.cursor()
        cur.execute("""
            SELECT ID_CHAT, DS_PROMPT, DS_RESPONSE, DT_CRIACAO
            FROM TB_GS_CHAT_HISTORY
            WHERE ID_USUARIO = :id_usuario
            ORDER BY DT_CRIACAO DESC
            FETCH FIRST :limit ROWS ONLY
        """, {'id_usuario': user_id, 'limit': limit})
        
        results = cur.fetchall()
        return [
            {
                'id': row[0],
                'prompt': row[1].read() if hasattr(row[1], 'read') else row[1],  # Handle CLOB
                'response': row[2].read() if hasattr(row[2], 'read') else row[2],  # Handle CLOB
                'created_at': row[3]
            }
            for row in results
        ]

def get_user_info(user_id: int):
    """Recupera informações do usuário da tabela TB_GS_USUARIO"""
    with get_oracle_conn() as conn:
        cur = conn.cursor()
        cur.execute("""
            SELECT 
                ID_USUARIO,
                NM_USUARIO,
                DS_EMAIL,
                TP_PERFIL,
                TP_ROLE,
                NR_EXPERIENCIA,
                VL_AVALIACAO,
                DT_CRIACAO,
                FL_ATIVO
            FROM TB_GS_USUARIO
            WHERE ID_USUARIO = :id_usuario
        """, {'id_usuario': user_id})
        
        row = cur.fetchone()
        if not row:
            return None
        
        return {
            'id_usuario': row[0],
            'nome': row[1],
            'email': row[2],
            'perfil': row[3],  # JUNIOR, PLENO, SENIOR
            'role': row[4],  # USER, ADMIN
            'experiencia': row[5],  # anos de experiência
            'avaliacao': float(row[6]) if row[6] else None,
            'data_criacao': row[7],
            'ativo': row[8]
        }

def save_message_async(user_id: int, user_message: str) -> int:
    """
    Salva mensagem inicial (prompt) sem resposta usando PRC_INSERIR_CHAT_HISTORY.
    Retorna o ID do chat criado para posterior atualização.
    """
    with get_oracle_conn() as conn:
        cur = conn.cursor()
        
        # Variável de saída para receber o ID gerado
        id_chat = cur.var(int)
        
        # Chama a procedure com resposta NULL (será preenchida depois)
        cur.callproc('PKG_REMOTEREADY.PRC_INSERIR_CHAT_HISTORY', [
            user_id,           # P_ID_USUARIO
            user_message,      # P_PROMPT
            None,              # P_RESPONSE (NULL - será atualizado depois)
            id_chat            # P_ID_OUT
        ])
        
        conn.commit()
        return id_chat.getvalue()[0]

def update_chat_response(chat_id: int, bot_answer: str):
    """
    Atualiza a resposta do chat usando PRC_ATUALIZAR_CHAT_RESPONSE.
    Usado quando a resposta é gerada de forma assíncrona.
    """
    with get_oracle_conn() as conn:
        cur = conn.cursor()
        
        # Chama a procedure para atualizar a resposta
        cur.callproc('PKG_REMOTEREADY.PRC_ATUALIZAR_CHAT_RESPONSE', [
            chat_id,           # P_ID_CHAT
            bot_answer         # P_RESPONSE
        ])
        
        conn.commit()
